---
phase: 02-webhook-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/feishu/worker_pool.go
  - internal/feishu/worker_pool_test.go
autonomous: true

must_haves:
  truths:
    - "Worker pool 能接收任务并异步执行"
    - "队列满时提交返回错误而非阻塞"
    - "Worker panic 不会导致程序崩溃，继续处理下一个任务"
    - "优雅关闭时等待任务完成"
    - "Shutdown 后 Submit 返回 ErrClosed 而非 panic"
  artifacts:
    - path: "internal/feishu/worker_pool.go"
      provides: "WorkerPool 结构体和方法"
      exports: ["WorkerPool", "NewWorkerPool", "Job", "Start", "ErrQueueFull", "ErrClosed"]
      min_lines: 100
    - path: "internal/feishu/worker_pool_test.go"
      provides: "Worker pool 单元测试"
      contains: "TestWorkerPool"
  key_links:
    - from: "internal/feishu/worker_pool.go"
      to: "buffered channel"
      via: "jobQueue chan Job"
      pattern: "make\\(chan Job"
    - from: "WorkerPool.Submit"
      to: "closed state check"
      via: "sync.RWMutex + closed bool"
      pattern: "p\\.closed"
---

<objective>
实现 Worker Pool 并发控制模块，支持有界队列、panic recovery 和优雅关闭。

Purpose: Worker pool 是 webhook 异步处理的核心，确保 3 秒内返回 HTTP 200 同时控制并发资源。
Output: `internal/feishu/worker_pool.go` 可复用的 worker pool 实现。
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webhook-server/02-RESEARCH.md (Pattern 2: Worker Pool + Buffered Channel)
@internal/feishu/receiver.go (MessageHandler 类型定义)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现 WorkerPool 结构体</name>
  <files>internal/feishu/worker_pool.go</files>
  <action>
创建 `internal/feishu/worker_pool.go`，实现 Worker Pool 模式：

1. 定义错误和结构体：
```go
var (
    ErrQueueFull = errors.New("worker queue full")
    ErrClosed    = errors.New("worker pool closed")
)

type Job struct {
    EventID string
    Handler func() error  // 注意：返回 error
}

type WorkerPool struct {
    workers   int
    jobQueue  chan Job
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
    mu        sync.RWMutex  // 保护 closed 状态
    closed    bool          // 防止 send on closed channel
}
```

2. 实现 `NewWorkerPool(workers, queueSize int) *WorkerPool`
   - 使用 `context.WithCancel` 创建可取消的 context
   - 创建 buffered channel: `make(chan Job, queueSize)`
   - closed 初始化为 false

3. 实现 `Start()` 方法
   - 启动 N 个 worker goroutine
   - **使用 select 同时监听 jobQueue 和 ctx.Done()**
   - **关键：panic recovery 在每个 job 执行时包一层，不是 goroutine 顶层**
   ```go
   func (p *WorkerPool) Start() {
       for i := 0; i < p.workers; i++ {
           p.wg.Add(1)
           go func(workerID int) {
               defer p.wg.Done()
               for {
                   select {
                   case job, ok := <-p.jobQueue:
                       if !ok {
                           return  // channel 已关闭
                       }
                       // panic recovery 在每个 job 执行时包一层
                       func() {
                           defer func() {
                               if r := recover(); r != nil {
                                   log.Printf("[Worker %d] panic recovered: %v", workerID, r)
                               }
                           }()
                           if err := job.Handler(); err != nil {
                               log.Printf("[Worker %d] job %s error: %v", workerID, job.EventID, err)
                           }
                       }()
                   case <-p.ctx.Done():
                       return  // context 取消
                   }
               }
           }(i)
       }
   }
   ```

4. 实现 `Submit(job Job) error` 方法
   - **检查 closed 状态和非阻塞发送必须在同一个 RLock 临界区内**，避免竞态
   - 队列满时返回 `ErrQueueFull` 错误
   ```go
   func (p *WorkerPool) Submit(job Job) error {
       p.mu.RLock()
       defer p.mu.RUnlock()

       if p.closed {
           return ErrClosed
       }

       select {
       case p.jobQueue <- job:
           return nil
       default:
           return ErrQueueFull
       }
   }
   ```

5. 实现 `Shutdown(timeout time.Duration) error` 方法
   - **先获取写锁，设置 closed = true，然后 close(jobQueue)，最后释放锁**
   - 这样确保 close 与 Submit 发送不会并发
   ```go
   func (p *WorkerPool) Shutdown(timeout time.Duration) error {
       p.mu.Lock()
       p.closed = true
       close(p.jobQueue)
       p.mu.Unlock()

       // 等待所有 worker 完成
       done := make(chan struct{})
       go func() {
           p.wg.Wait()
           close(done)
       }()

       select {
       case <-done:
           return nil
       case <-time.After(timeout):
           p.cancel()  // 强制取消
           return errors.New("shutdown timeout")
       }
   }
   ```

6. 实现 `QueueLen() int` 方法
   - 返回 `len(p.jobQueue)` 用于 metrics

日志格式参考现有 ws_receiver.go 的风格：`log.Printf("[Worker] ...")`
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
WorkerPool 结构体和所有方法实现完成，编译通过
  </done>
</task>

<task type="auto">
  <name>Task 2: 添加 WorkerPool 单元测试</name>
  <files>internal/feishu/worker_pool_test.go</files>
  <action>
创建 `internal/feishu/worker_pool_test.go`，测试关键场景：

1. `TestWorkerPool_Submit` - 正常提交和执行
   - 创建 pool (2 workers, 10 queue)
   - 提交任务，验证任务被执行
   - 使用 channel 或 atomic counter 验证执行
   - 验证 Job.Handler 返回的 error 被记录

2. `TestWorkerPool_QueueFull` - 队列满时返回错误
   - 创建 pool (1 worker, 2 queue)
   - 提交阻塞任务填满队列
   - 验证下一次 Submit 返回 ErrQueueFull

3. `TestWorkerPool_PanicRecovery` - panic 不崩溃，继续处理
   - 提交一个 panic 的任务
   - **验证后续任务仍然执行（同一个 worker 继续工作）**
   - 验证 pool 没有死锁
   - 验证 worker 数量没有减少

4. `TestWorkerPool_Shutdown` - 优雅关闭
   - 提交多个任务
   - 调用 Shutdown
   - 验证所有任务执行完成

5. `TestWorkerPool_SubmitAfterShutdown` - 关闭后提交返回 ErrClosed
   - 调用 Shutdown
   - 再次 Submit
   - **验证返回 ErrClosed 而非 panic**
  </action>
  <verify>
`go test -v ./internal/feishu/... -run TestWorkerPool` 所有测试通过
  </verify>
  <done>
4 个测试用例全部通过，覆盖正常执行、队列满、panic recovery、优雅关闭场景
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/feishu/...` 编译成功
- [ ] `go test -v ./internal/feishu/... -run TestWorkerPool` 全部通过（5 个测试）
- [ ] WorkerPool 导出正确的接口：NewWorkerPool, Start, Submit, Shutdown, QueueLen
- [ ] ErrQueueFull 和 ErrClosed 错误可供调用方判断
- [ ] panic recovery 在 job 执行层（不是 goroutine 顶层），panic 后 worker 继续处理
- [ ] Shutdown 后 Submit 返回 ErrClosed 而非 panic
</verification>

<success_criteria>
- WorkerPool 实现完整，支持有界队列、panic recovery、优雅关闭
- Shutdown 竞态安全（closed 标记 + sync.RWMutex）
- 测试覆盖所有关键场景（包括 SubmitAfterShutdown）
- 代码风格与现有代码一致
</success_criteria>

<output>
After completion, create `.planning/phases/02-webhook-server/02-01-SUMMARY.md`
</output>
