---
phase: 02-webhook-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/feishu/worker_pool.go
  - internal/feishu/worker_pool_test.go
autonomous: true

must_haves:
  truths:
    - "Worker pool 能接收任务并异步执行"
    - "队列满时提交返回错误而非阻塞"
    - "Worker panic 不会导致程序崩溃"
    - "优雅关闭时等待任务完成"
  artifacts:
    - path: "internal/feishu/worker_pool.go"
      provides: "WorkerPool 结构体和方法"
      exports: ["WorkerPool", "NewWorkerPool", "Job"]
      min_lines: 80
    - path: "internal/feishu/worker_pool_test.go"
      provides: "Worker pool 单元测试"
      contains: "TestWorkerPool"
  key_links:
    - from: "internal/feishu/worker_pool.go"
      to: "buffered channel"
      via: "jobQueue chan Job"
      pattern: "make\\(chan Job"
---

<objective>
实现 Worker Pool 并发控制模块，支持有界队列、panic recovery 和优雅关闭。

Purpose: Worker pool 是 webhook 异步处理的核心，确保 3 秒内返回 HTTP 200 同时控制并发资源。
Output: `internal/feishu/worker_pool.go` 可复用的 worker pool 实现。
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webhook-server/02-RESEARCH.md (Pattern 2: Worker Pool + Buffered Channel)
@internal/feishu/receiver.go (MessageHandler 类型定义)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现 WorkerPool 结构体</name>
  <files>internal/feishu/worker_pool.go</files>
  <action>
创建 `internal/feishu/worker_pool.go`，实现 Worker Pool 模式：

1. 定义结构体：
```go
type Job struct {
    EventID string
    Handler func() error
}

type WorkerPool struct {
    workers   int
    jobQueue  chan Job
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
}
```

2. 实现 `NewWorkerPool(workers, queueSize int) *WorkerPool`
   - 使用 `context.WithCancel` 创建可取消的 context
   - 创建 buffered channel: `make(chan Job, queueSize)`

3. 实现 `Start()` 方法
   - 启动 N 个 worker goroutine
   - 每个 worker 使用 `defer recover()` 捕获 panic
   - Panic 后记录日志并继续处理下一个任务（不退出）
   - 使用 `select` 监听 jobQueue 和 ctx.Done()

4. 实现 `Submit(job Job) error` 方法
   - 使用 `select` + `default` 非阻塞发送
   - 队列满时返回 `ErrQueueFull` 错误（定义 `var ErrQueueFull = errors.New("worker queue full")`）

5. 实现 `Shutdown(timeout time.Duration) error` 方法
   - 先关闭 jobQueue（停止接收新任务）
   - 等待所有 worker 完成（使用 sync.WaitGroup）
   - 超时后调用 cancel() 强制取消
   - 返回是否超时的错误

6. 实现 `QueueLen() int` 方法
   - 返回 `len(p.jobQueue)` 用于 metrics

日志格式参考现有 ws_receiver.go 的风格：`log.Printf("[Worker] ...")`
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
WorkerPool 结构体和所有方法实现完成，编译通过
  </done>
</task>

<task type="auto">
  <name>Task 2: 添加 WorkerPool 单元测试</name>
  <files>internal/feishu/worker_pool_test.go</files>
  <action>
创建 `internal/feishu/worker_pool_test.go`，测试关键场景：

1. `TestWorkerPool_Submit` - 正常提交和执行
   - 创建 pool (2 workers, 10 queue)
   - 提交任务，验证任务被执行
   - 使用 channel 或 atomic counter 验证执行

2. `TestWorkerPool_QueueFull` - 队列满时返回错误
   - 创建 pool (1 worker, 2 queue)
   - 提交阻塞任务填满队列
   - 验证下一次 Submit 返回 ErrQueueFull

3. `TestWorkerPool_PanicRecovery` - panic 不崩溃
   - 提交一个 panic 的任务
   - 验证后续任务仍然执行
   - 验证 pool 没有死锁

4. `TestWorkerPool_Shutdown` - 优雅关闭
   - 提交多个任务
   - 调用 Shutdown
   - 验证所有任务执行完成
  </action>
  <verify>
`go test -v ./internal/feishu/... -run TestWorkerPool` 所有测试通过
  </verify>
  <done>
4 个测试用例全部通过，覆盖正常执行、队列满、panic recovery、优雅关闭场景
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/feishu/...` 编译成功
- [ ] `go test -v ./internal/feishu/... -run TestWorkerPool` 全部通过
- [ ] WorkerPool 导出正确的接口：NewWorkerPool, Submit, Shutdown, QueueLen
- [ ] ErrQueueFull 错误可供调用方判断
</verification>

<success_criteria>
- WorkerPool 实现完整，支持有界队列、panic recovery、优雅关闭
- 测试覆盖所有关键场景
- 代码风格与现有代码一致
</success_criteria>

<output>
After completion, create `.planning/phases/02-webhook-server/02-01-SUMMARY.md`
</output>
