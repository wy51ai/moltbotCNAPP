---
phase: 02-webhook-server
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/feishu/webhook_receiver.go
  - internal/feishu/webhook_receiver_test.go
autonomous: true

must_haves:
  truths:
    - "Webhook 能接收飞书 HTTP POST 请求"
    - "Challenge 请求正确返回 challenge 值"
    - "签名验证失败返回 401（自定义错误码映射）"
    - "Body 超限返回 413（自定义错误码映射）"
    - "队列满返回 503（自定义错误码映射）"
    - "加密消息自动解密（SDK 处理）"
    - "消息事件触发 MessageHandler 回调"
    - "消息处理异步执行，HTTP 立即返回 200"
  artifacts:
    - path: "internal/feishu/webhook_receiver.go"
      provides: "WebhookReceiver 实现 FeishuReceiver 接口"
      exports: ["WebhookReceiver", "NewWebhookReceiver", "WebhookConfig"]
      min_lines: 200
    - path: "internal/feishu/webhook_receiver_test.go"
      provides: "Webhook 处理测试"
      contains: "TestWebhookReceiver"
  key_links:
    - from: "internal/feishu/webhook_receiver.go"
      to: "internal/feishu/worker_pool.go"
      via: "workerPool.Submit"
      pattern: "workerPool\\.Submit"
    - from: "internal/feishu/webhook_receiver.go"
      to: "SDK dispatcher"
      via: "dispatcher 解析和验证"
      pattern: "dispatcher\\.NewEventDispatcher"
    - from: "WebhookReceiver event handler"
      to: "MessageHandler"
      via: "Job.Handler func() error 在 worker 中执行"
      pattern: "wr\\.handler\\("
    - from: "HTTP handler"
      to: "自定义错误码映射"
      via: "不使用 httpserverext 全托管"
      pattern: "http\\.StatusUnauthorized\\|http\\.StatusServiceUnavailable"
---

<objective>
实现 WebhookReceiver，使用飞书 SDK 处理 webhook 事件，实现 FeishuReceiver 接口。

Purpose: WebhookReceiver 是 webhook 模式的核心，接收飞书回调并转换为与 WebSocket 模式兼容的 Message 结构。
Output: `internal/feishu/webhook_receiver.go` 完整的 webhook 接收器实现。
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webhook-server/02-RESEARCH.md (Pattern 1, 3, 4: SDK Dispatcher, HTTP Server, Graceful Shutdown)
@.planning/phases/02-webhook-server/02-01-SUMMARY.md
@internal/feishu/receiver.go (FeishuReceiver 接口定义)
@internal/feishu/ws_receiver.go (Message 结构体和 handleMessage 参考)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现 WebhookReceiver 结构体和配置</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
创建 `internal/feishu/webhook_receiver.go`，实现 webhook 接收器：

1. 定义配置结构体：
```go
type WebhookConfig struct {
    Port              int    // 默认 8080
    Path              string // 默认 "/webhook/feishu"
    VerificationToken string // 必填，用于 challenge 验证
    EncryptKey        string // 必填，用于消息解密（飞书会加密 webhook payload）
    Workers           int    // 默认 10
    QueueSize         int    // 默认 100
}
```

2. 定义 WebhookReceiver 结构体：
```go
type WebhookReceiver struct {
    config      WebhookConfig
    handler     MessageHandler
    workerPool  *WorkerPool
    dedupeCache sync.Map  // event_id -> time.Time
    server      *http.Server
}
```

3. 实现 `NewWebhookReceiver(config WebhookConfig, handler MessageHandler) *WebhookReceiver`
   - 设置默认值（Port=8080, Path="/webhook/feishu", Workers=10, QueueSize=100）
   - 创建 WorkerPool
   - 验证必填字段（VerificationToken, EncryptKey），缺失则 panic

4. 接口合规检查：
```go
var _ FeishuReceiver = (*WebhookReceiver)(nil)
```
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
WebhookReceiver 结构体和 NewWebhookReceiver 构造函数实现完成
  </done>
</task>

<task type="auto">
  <name>Task 2: 实现 Start 方法和事件处理</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
在 `internal/feishu/webhook_receiver.go` 中添加 Start 方法和事件处理：

1. 实现 `Start(ctx context.Context) error` 方法：
   - 启动 WorkerPool
   - 启动去重缓存清理 goroutine（每分钟清理 10 分钟前的 entry）

2. **创建 SDK EventDispatcher（关键：配置 EncryptKey 实现消息自动解密）**：
```go
eventDispatcher := dispatcher.NewEventDispatcher(
    wr.config.VerificationToken,  // 用于 challenge 验证和签名校验
    wr.config.EncryptKey,         // 用于消息解密，SDK 自动解密加密的 payload
)
```
**消息解密流程说明**：飞书在开启消息加密后，webhook payload 会被加密。SDK EventDispatcher 使用 EncryptKey 自动解密，应用代码无需手动处理解密逻辑。

3. 注册 OnP2MessageReceiveV1 事件处理，**明确 MessageHandler 调用链**：
```go
eventDispatcher.OnP2MessageReceiveV1(func(ctx context.Context, event *larkim.P2MessageReceiveV1) error {
    // 1. 获取 event_id 用于去重（**注意：正确字段是 event.Header.EventID**）
    eventID := *event.Header.EventID

    // 2. 检查去重缓存，重复事件记录日志并返回 nil
    if _, exists := wr.dedupeCache.LoadOrStore(eventID, time.Now()); exists {
        log.Printf("[Webhook] Duplicate event ignored: %s", eventID)
        return nil
    }

    // 3. 将事件转换为 Message 并创建 Job
    msg := convertEventToMessage(event)
    job := Job{
        EventID: eventID,
        Handler: func() error {  // **注意：返回 error**
            // **关键：这里调用 MessageHandler 处理消息**
            return wr.handler(msg)
        },
    }

    // 4. 提交到 WorkerPool
    if err := wr.workerPool.Submit(job); err != nil {
        log.Printf("[Webhook] Queue full, event %s will be retried", eventID)
        return err  // 返回 error，在 HTTP handler 中映射为 503
    }

    return nil
})
```

4. **创建自定义 HTTP Handler（不使用 httpserverext 全托管，实现正确的错误码映射）**：

**重要：飞书 SDK httpserverext 默认对错误返回 500，无法满足 401/503/413 的需求。需要自定义 handler。**

```go
mux.HandleFunc(wr.config.Path, func(w http.ResponseWriter, r *http.Request) {
    // 4.1 方法检查
    if r.Method != http.MethodPost {
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
        return
    }

    // 4.2 Body 大小限制（超限返回 413）
    r.Body = http.MaxBytesReader(w, r.Body, 1<<20)  // 1MB
    body, err := io.ReadAll(r.Body)
    if err != nil {
        var maxBytesErr *http.MaxBytesError
        if errors.As(err, &maxBytesErr) {
            http.Error(w, "Request Entity Too Large", http.StatusRequestEntityTooLarge)  // 413
            return
        }
        http.Error(w, "Bad Request", http.StatusBadRequest)
        return
    }

    // 4.3 Challenge 处理（SDK 解析后判断）
    // 使用 SDK 的 ParseReq 解析请求

    // 4.4 签名验证（失败返回 401）
    // 使用 SDK 的 VerifySign，失败返回 http.StatusUnauthorized

    // 4.5 消息解密（SDK 自动处理）
    // 使用 SDK 的 DecryptEvent

    // 4.6 事件分发
    // 调用 eventDispatcher 处理事件

    // 4.7 队列满时返回 503
    // 如果 Submit 返回 ErrQueueFull，返回 http.StatusServiceUnavailable

    // 4.8 成功返回 200
    w.WriteHeader(http.StatusOK)
})
```

**实现建议**：参考 SDK 的 `event/dispatcher` 包的 `Do` 方法，手动调用 `ParseReq`、`VerifySign`、`DecryptEvent`、`DoHandle`，在每个步骤根据错误类型返回正确的 HTTP 状态码。

5. 配置 HTTP Server：
```go
srv := &http.Server{
    Addr:              fmt.Sprintf(":%d", config.Port),
    Handler:           mux,
    ReadTimeout:       10 * time.Second,
    WriteTimeout:      10 * time.Second,
    IdleTimeout:       60 * time.Second,
    ReadHeaderTimeout: 5 * time.Second,
}
```

6. 优雅关闭：
   - 监听 ctx.Done()
   - 调用 srv.Shutdown(30 秒超时)
   - 调用 workerPool.Shutdown(30 秒超时)

7. 日志输出：
   - 启动时打印配置摘要：`[Webhook] Starting server on :8080/webhook/feishu (workers=10, queue=100)`
   - 签名验证失败：`[Webhook] Signature verification failed from %s`（记录 IP）
   - 重复事件：`[Webhook] Duplicate event ignored: %s`
   - 队列满：`[Webhook] Queue full, event %s will be retried`

8. 实现 `convertEventToMessage` 私有方法：
   - 将 `*larkim.P2MessageReceiveV1` 转换为 `*Message`
   - 参考 ws_receiver.go 的 handleMessage 实现
   - 复用 getStringValue 辅助函数
  </action>
  <verify>
1. `go build ./internal/feishu/...` 编译成功
2. `go test -v ./internal/feishu/... -run TestWebhookReceiver` 单元测试通过
3. （可选）手动验证：启动 server 后用 curl 测试
   - Challenge: `curl -X POST localhost:8080/webhook/feishu -d '{"challenge":"test"}' -H 'Content-Type: application/json'` 应返回 challenge
   - Method: `curl localhost:8080/webhook/feishu` 应返回 405
  </verify>
  <done>
Start 方法完整实现，包含：
- SDK dispatcher 配置（VerificationToken + EncryptKey）
- 消息自动解密（SDK 处理）
- MessageHandler 调用链（event -> convertEventToMessage -> Job{Handler: func() error} -> wr.handler）
- **自定义 HTTP handler 实现正确的错误码映射（401/413/503）**
- event_id 正确引用：event.Header.EventID
- HTTP server 配置
- 优雅关闭
  </done>
</task>

<task type="auto">
  <name>Task 3: 添加 WebhookReceiver 单元测试</name>
  <files>internal/feishu/webhook_receiver_test.go</files>
  <action>
创建 `internal/feishu/webhook_receiver_test.go`，测试关键场景：

**先创建测试 helper（构造签名和加密 payload）**：
```go
// testHelper.go 或 webhook_receiver_test.go 顶部
func generateSignature(timestamp, nonce, encryptKey, body string) string {
    // 按飞书签名算法：sha256(timestamp + nonce + encryptKey + body)
}

func encryptPayload(plaintext, encryptKey string) string {
    // AES-CBC 加密，返回 base64
}
```

1. `TestWebhookReceiver_MethodNotAllowed` - 非 POST 请求
   - 发送 GET 请求
   - 验证返回 405

2. `TestWebhookReceiver_BodyTooLarge` - Body 超限返回 413
   - 发送超过 1MB 的 body
   - 验证返回 413 Request Entity Too Large

3. `TestWebhookReceiver_Challenge` - URL 验证
   - 构造 challenge 请求 payload（无需签名）
   - 验证正确返回 challenge 值

4. `TestWebhookReceiver_InvalidSignature` - 签名验证失败返回 401
   - 发送带错误签名的请求
   - **验证返回 401 Unauthorized**

5. `TestWebhookReceiver_QueueFull` - 队列满返回 503
   - 先填满队列
   - 发送新请求
   - **验证返回 503 Service Unavailable**

6. `TestWebhookReceiver_MessageEvent` - 消息事件处理
   - 使用 helper 构造正确签名的加密 payload
   - 验证 MessageHandler 被调用
   - 验证返回 200

**测试策略**：
- 方法检查、body 限制：纯 HTTP 测试，无需签名
- Challenge：无需签名验证
- 签名验证：构造错误签名验证 401
- 队列满：需要完整流程，可能需要集成测试环境
- 建议将需要真实签名的测试放在 `_integration_test.go` 或使用 build tag
  </action>
  <verify>
`go test -v ./internal/feishu/... -run TestWebhookReceiver` 测试通过（可能有部分 skip）
  </verify>
  <done>
WebhookReceiver 测试实现，覆盖 HTTP 层面逻辑和可测试的场景
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/feishu/...` 编译成功
- [ ] `go test -v ./internal/feishu/...` 全部通过
- [ ] WebhookReceiver 实现 FeishuReceiver 接口
- [ ] HTTP Server 配置正确（超时、body 限制）
- [ ] **自定义错误码映射正确**：
  - 签名验证失败 → 401 Unauthorized
  - Body 超限 → 413 Request Entity Too Large
  - 队列满 → 503 Service Unavailable
- [ ] 事件处理流程：去重 -> 提交队列 -> Job.Handler(func() error) -> wr.handler(msg)
- [ ] EncryptKey 正确配置到 EventDispatcher，加密消息自动解密
- [ ] event_id 字段引用正确：`event.Header.EventID`
</verification>

<success_criteria>
- WebhookReceiver 完整实现 FeishuReceiver 接口
- **不使用 httpserverext 全托管**，自定义 HTTP handler 实现正确的错误码
- 使用 SDK dispatcher 的 ParseReq/VerifySign/DecryptEvent/DoHandle
- EncryptKey 配置正确，加密消息由 SDK 自动解密
- Job.Handler 签名为 func() error，与 WorkerPool 一致
- MessageHandler 在 worker goroutine 中被调用
- 事件异步处理，HTTP 立即返回 200
- 优雅关闭等待任务完成
</success_criteria>

<output>
After completion, create `.planning/phases/02-webhook-server/02-02-SUMMARY.md`
</output>
