---
phase: 02-webhook-server
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/feishu/webhook_receiver.go
  - internal/feishu/webhook_receiver_test.go
autonomous: true

must_haves:
  truths:
    - "Webhook 能接收飞书 HTTP POST 请求"
    - "Challenge 请求正确返回 challenge 值"
    - "签名验证失败返回 401"
    - "加密消息自动解密（SDK 处理）"
    - "消息事件触发 MessageHandler 回调"
    - "消息处理异步执行，HTTP 立即返回 200"
  artifacts:
    - path: "internal/feishu/webhook_receiver.go"
      provides: "WebhookReceiver 实现 FeishuReceiver 接口"
      exports: ["WebhookReceiver", "NewWebhookReceiver", "WebhookConfig"]
      min_lines: 150
    - path: "internal/feishu/webhook_receiver_test.go"
      provides: "Webhook 处理测试"
      contains: "TestWebhookReceiver"
  key_links:
    - from: "internal/feishu/webhook_receiver.go"
      to: "internal/feishu/worker_pool.go"
      via: "workerPool.Submit"
      pattern: "workerPool\\.Submit"
    - from: "internal/feishu/webhook_receiver.go"
      to: "SDK dispatcher"
      via: "dispatcher.NewEventDispatcher"
      pattern: "dispatcher\\.NewEventDispatcher"
    - from: "WebhookReceiver event handler"
      to: "MessageHandler"
      via: "Job.Handler 在 worker 中执行"
      pattern: "wr\\.handler\\(convertEventToMessage"
---

<objective>
实现 WebhookReceiver，使用飞书 SDK 处理 webhook 事件，实现 FeishuReceiver 接口。

Purpose: WebhookReceiver 是 webhook 模式的核心，接收飞书回调并转换为与 WebSocket 模式兼容的 Message 结构。
Output: `internal/feishu/webhook_receiver.go` 完整的 webhook 接收器实现。
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webhook-server/02-RESEARCH.md (Pattern 1, 3, 4: SDK Dispatcher, HTTP Server, Graceful Shutdown)
@.planning/phases/02-webhook-server/02-01-SUMMARY.md
@internal/feishu/receiver.go (FeishuReceiver 接口定义)
@internal/feishu/ws_receiver.go (Message 结构体和 handleMessage 参考)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现 WebhookReceiver 结构体和配置</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
创建 `internal/feishu/webhook_receiver.go`，实现 webhook 接收器：

1. 定义配置结构体：
```go
type WebhookConfig struct {
    Port              int    // 默认 8080
    Path              string // 默认 "/webhook/feishu"
    VerificationToken string // 必填，用于 challenge 验证
    EncryptKey        string // 必填，用于消息解密（飞书会加密 webhook payload）
    Workers           int    // 默认 10
    QueueSize         int    // 默认 100
}
```

2. 定义 WebhookReceiver 结构体：
```go
type WebhookReceiver struct {
    config      WebhookConfig
    handler     MessageHandler
    workerPool  *WorkerPool
    dedupeCache sync.Map  // event_id -> time.Time
    server      *http.Server
}
```

3. 实现 `NewWebhookReceiver(config WebhookConfig, handler MessageHandler) *WebhookReceiver`
   - 设置默认值（Port=8080, Path="/webhook/feishu", Workers=10, QueueSize=100）
   - 创建 WorkerPool
   - 验证必填字段（VerificationToken, EncryptKey），缺失则 panic

4. 接口合规检查：
```go
var _ FeishuReceiver = (*WebhookReceiver)(nil)
```
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
WebhookReceiver 结构体和 NewWebhookReceiver 构造函数实现完成
  </done>
</task>

<task type="auto">
  <name>Task 2: 实现 Start 方法和事件处理</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
在 `internal/feishu/webhook_receiver.go` 中添加 Start 方法和事件处理：

1. 实现 `Start(ctx context.Context) error` 方法：
   - 启动 WorkerPool
   - 启动去重缓存清理 goroutine（每分钟清理 10 分钟前的 entry）

2. **创建 SDK EventDispatcher（关键：配置 EncryptKey 实现消息自动解密）**：
```go
dispatcher := dispatcher.NewEventDispatcher(
    wr.config.VerificationToken,  // 用于 challenge 验证和签名校验
    wr.config.EncryptKey,         // 用于消息解密，SDK 自动解密加密的 payload
)
```
**消息解密流程说明**：飞书在开启消息加密后，webhook payload 会被加密。SDK EventDispatcher 使用 EncryptKey 自动解密，应用代码无需手动处理解密逻辑。

3. 注册 OnP2MessageReceiveV1 事件处理，**明确 MessageHandler 调用链**：
```go
dispatcher.OnP2MessageReceiveV1(func(ctx context.Context, event *larkim.P2MessageReceiveV1) error {
    // 1. 获取 event_id 用于去重
    eventID := event.EventV2Base.Header.EventID

    // 2. 检查去重缓存，重复事件记录日志并返回 nil
    if _, exists := wr.dedupeCache.LoadOrStore(eventID, time.Now()); exists {
        log.Printf("[Webhook] Duplicate event ignored: %s", eventID)
        return nil
    }

    // 3. 将事件转换为 Message 并创建 Job
    msg := convertEventToMessage(event)
    job := &Job{
        Handler: func() {
            // **关键：这里调用 MessageHandler 处理消息**
            wr.handler(msg)
        },
    }

    // 4. 提交到 WorkerPool，队列满时返回 error（SDK 返回 503）
    if err := wr.workerPool.Submit(job); err != nil {
        log.Printf("[Webhook] Queue full, event %s will be retried", eventID)
        return err
    }

    return nil
})
```

4. 创建 HTTP Handler：
   - 使用 `http.MaxBytesReader(w, r.Body, 1<<20)` 限制 body 为 1MB
   - 检查请求方法，非 POST 返回 405 Method Not Allowed
   - 委托给 `httpserverext.NewEventHandlerFunc(dispatcher)` 处理：
     - Challenge 请求：SDK 自动响应
     - 签名验证：SDK 使用 VerificationToken 验证，失败返回 401
     - 消息解密：SDK 使用 EncryptKey 自动解密
     - 事件分发：SDK 调用注册的 OnP2MessageReceiveV1 回调

5. 配置 HTTP Server：
```go
srv := &http.Server{
    Addr:              fmt.Sprintf(":%d", config.Port),
    Handler:           mux,
    ReadTimeout:       10 * time.Second,
    WriteTimeout:      10 * time.Second,
    IdleTimeout:       60 * time.Second,
    ReadHeaderTimeout: 5 * time.Second,
}
```

6. 优雅关闭：
   - 监听 ctx.Done()
   - 调用 srv.Shutdown(30 秒超时)
   - 调用 workerPool.Shutdown(30 秒超时)

7. 日志输出：
   - 启动时打印配置摘要：`[Webhook] Starting server on :8080/webhook/feishu (workers=10, queue=100)`
   - 签名验证失败：`[Webhook] Signature verification failed from %s`（记录 IP）
   - 重复事件：`[Webhook] Duplicate event ignored: %s`
   - 队列满：`[Webhook] Queue full, event %s will be retried`

8. 实现 `convertEventToMessage` 私有方法：
   - 将 `*larkim.P2MessageReceiveV1` 转换为 `*Message`
   - 参考 ws_receiver.go 的 handleMessage 实现
   - 复用 getStringValue 辅助函数
  </action>
  <verify>
1. `go build ./internal/feishu/...` 编译成功
2. `go test -v ./internal/feishu/... -run TestWebhookReceiver` 单元测试通过
3. （可选）手动验证：启动 server 后用 curl 测试
   - Challenge: `curl -X POST localhost:8080/webhook/feishu -d '{"challenge":"test"}' -H 'Content-Type: application/json'` 应返回 challenge
   - Method: `curl localhost:8080/webhook/feishu` 应返回 405
  </verify>
  <done>
Start 方法完整实现，包含：
- SDK dispatcher 配置（VerificationToken + EncryptKey）
- 消息自动解密（SDK 处理）
- MessageHandler 调用链（event -> convertEventToMessage -> Job.Handler -> wr.handler）
- HTTP server 配置
- 优雅关闭
  </done>
</task>

<task type="auto">
  <name>Task 3: 添加 WebhookReceiver 单元测试</name>
  <files>internal/feishu/webhook_receiver_test.go</files>
  <action>
创建 `internal/feishu/webhook_receiver_test.go`，测试关键场景：

1. `TestWebhookReceiver_MethodNotAllowed` - 非 POST 请求
   - 发送 GET 请求
   - 验证返回 405

2. `TestWebhookReceiver_Challenge` - URL 验证
   - 构造 challenge 请求 payload
   - 验证正确返回 challenge 值

3. `TestWebhookReceiver_InvalidSignature` - 签名验证失败
   - 发送带错误签名的请求
   - 验证返回 401（或 SDK 的错误响应）

4. `TestWebhookReceiver_MessageEvent` - 消息事件处理
   - 需要 mock 或跳过签名验证（可以用测试专用的 token）
   - 验证 MessageHandler 被调用

注意：飞书 SDK 的签名验证较难在单元测试中模拟，可以：
- 使用空字符串作为 token/key 跳过验证（如果 SDK 支持）
- 使用表驱动测试，标记需要真实环境的测试为 skip
- 重点测试 HTTP 层面的逻辑（method check, body limit）
  </action>
  <verify>
`go test -v ./internal/feishu/... -run TestWebhookReceiver` 测试通过（可能有部分 skip）
  </verify>
  <done>
WebhookReceiver 测试实现，覆盖 HTTP 层面逻辑和可测试的场景
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/feishu/...` 编译成功
- [ ] `go test -v ./internal/feishu/...` 全部通过
- [ ] WebhookReceiver 实现 FeishuReceiver 接口
- [ ] HTTP Server 配置正确（超时、body 限制）
- [ ] 事件处理流程：去重 -> 提交队列 -> Job.Handler 调用 wr.handler(msg) -> 异步执行
- [ ] EncryptKey 正确配置到 EventDispatcher，加密消息自动解密
</verification>

<success_criteria>
- WebhookReceiver 完整实现 FeishuReceiver 接口
- 使用 SDK dispatcher 处理 challenge、签名、解密
- EncryptKey 配置正确，加密消息由 SDK 自动解密
- MessageHandler 在 worker goroutine 中被调用
- 事件异步处理，HTTP 立即返回
- 优雅关闭等待任务完成
</success_criteria>

<output>
After completion, create `.planning/phases/02-webhook-server/02-02-SUMMARY.md`
</output>
