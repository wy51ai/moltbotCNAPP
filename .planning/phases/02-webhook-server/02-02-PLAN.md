---
phase: 02-webhook-server
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/feishu/webhook_receiver.go
  - internal/feishu/webhook_receiver_test.go
autonomous: true

must_haves:
  truths:
    - "Webhook 能接收飞书 HTTP POST 请求"
    - "Challenge 请求正确返回 challenge 值"
    - "签名验证失败返回 401"
    - "消息事件触发 MessageHandler 回调"
    - "消息处理异步执行，HTTP 立即返回 200"
  artifacts:
    - path: "internal/feishu/webhook_receiver.go"
      provides: "WebhookReceiver 实现 FeishuReceiver 接口"
      exports: ["WebhookReceiver", "NewWebhookReceiver", "WebhookConfig"]
      min_lines: 150
    - path: "internal/feishu/webhook_receiver_test.go"
      provides: "Webhook 处理测试"
      contains: "TestWebhookReceiver"
  key_links:
    - from: "internal/feishu/webhook_receiver.go"
      to: "internal/feishu/worker_pool.go"
      via: "workerPool.Submit"
      pattern: "workerPool\\.Submit"
    - from: "internal/feishu/webhook_receiver.go"
      to: "SDK dispatcher"
      via: "dispatcher.NewEventDispatcher"
      pattern: "dispatcher\\.NewEventDispatcher"
---

<objective>
实现 WebhookReceiver，使用飞书 SDK 处理 webhook 事件，实现 FeishuReceiver 接口。

Purpose: WebhookReceiver 是 webhook 模式的核心，接收飞书回调并转换为与 WebSocket 模式兼容的 Message 结构。
Output: `internal/feishu/webhook_receiver.go` 完整的 webhook 接收器实现。
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webhook-server/02-RESEARCH.md (Pattern 1, 3, 4: SDK Dispatcher, HTTP Server, Graceful Shutdown)
@.planning/phases/02-webhook-server/02-01-SUMMARY.md
@internal/feishu/receiver.go (FeishuReceiver 接口定义)
@internal/feishu/ws_receiver.go (Message 结构体和 handleMessage 参考)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现 WebhookReceiver 结构体和配置</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
创建 `internal/feishu/webhook_receiver.go`，实现 webhook 接收器：

1. 定义配置结构体：
```go
type WebhookConfig struct {
    Port              int    // 默认 8080
    Path              string // 默认 "/webhook/feishu"
    VerificationToken string // 必填
    EncryptKey        string // 必填
    Workers           int    // 默认 10
    QueueSize         int    // 默认 100
}
```

2. 定义 WebhookReceiver 结构体：
```go
type WebhookReceiver struct {
    config      WebhookConfig
    handler     MessageHandler
    workerPool  *WorkerPool
    dedupeCache sync.Map  // event_id -> time.Time
    server      *http.Server
}
```

3. 实现 `NewWebhookReceiver(config WebhookConfig, handler MessageHandler) *WebhookReceiver`
   - 设置默认值（Port=8080, Path="/webhook/feishu", Workers=10, QueueSize=100）
   - 创建 WorkerPool
   - 验证必填字段（VerificationToken, EncryptKey），缺失则 panic

4. 接口合规检查：
```go
var _ FeishuReceiver = (*WebhookReceiver)(nil)
```
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
WebhookReceiver 结构体和 NewWebhookReceiver 构造函数实现完成
  </done>
</task>

<task type="auto">
  <name>Task 2: 实现 Start 方法和事件处理</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
在 `internal/feishu/webhook_receiver.go` 中添加 Start 方法和事件处理：

1. 实现 `Start(ctx context.Context) error` 方法：
   - 启动 WorkerPool
   - 启动去重缓存清理 goroutine（每分钟清理 10 分钟前的 entry）
   - 创建 SDK EventDispatcher（使用 VerificationToken 和 EncryptKey）
   - 注册 OnP2MessageReceiveV1 事件处理

2. 事件处理逻辑（在 OnP2MessageReceiveV1 回调中）：
   - 获取 event_id，检查去重缓存
   - 重复事件：记录日志并返回 nil
   - 新事件：添加到去重缓存，创建 Job 提交到 WorkerPool
   - 队列满时：记录日志，返回 error（SDK 会返回 503）

3. 创建 HTTP Handler：
   - 使用 `http.MaxBytesReader(w, r.Body, 1<<20)` 限制 body 为 1MB
   - 检查请求方法，非 POST 返回 405 Method Not Allowed
   - 委托给 `httpserverext.NewEventHandlerFunc`

4. 配置 HTTP Server：
```go
srv := &http.Server{
    Addr:              fmt.Sprintf(":%d", config.Port),
    Handler:           mux,
    ReadTimeout:       10 * time.Second,
    WriteTimeout:      10 * time.Second,
    IdleTimeout:       60 * time.Second,
    ReadHeaderTimeout: 5 * time.Second,
}
```

5. 优雅关闭：
   - 监听 ctx.Done()
   - 调用 srv.Shutdown(30 秒超时)
   - 调用 workerPool.Shutdown(30 秒超时)

6. 日志输出：
   - 启动时打印配置摘要：`[Webhook] Starting server on :8080/webhook/feishu (workers=10, queue=100)`
   - 签名验证失败：`[Webhook] Signature verification failed from %s`（记录 IP）
   - 重复事件：`[Webhook] Duplicate event ignored: %s`
   - 队列满：`[Webhook] Queue full, event %s will be retried`

7. 实现 `convertEventToMessage` 私有方法：
   - 将 `*larkim.P2MessageReceiveV1` 转换为 `*Message`
   - 参考 ws_receiver.go 的 handleMessage 实现
   - 复用 getStringValue 辅助函数
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
Start 方法完整实现，包含 SDK dispatcher、HTTP server、优雅关闭、事件转换
  </done>
</task>

<task type="auto">
  <name>Task 3: 添加 WebhookReceiver 单元测试</name>
  <files>internal/feishu/webhook_receiver_test.go</files>
  <action>
创建 `internal/feishu/webhook_receiver_test.go`，测试关键场景：

1. `TestWebhookReceiver_MethodNotAllowed` - 非 POST 请求
   - 发送 GET 请求
   - 验证返回 405

2. `TestWebhookReceiver_Challenge` - URL 验证
   - 构造 challenge 请求 payload
   - 验证正确返回 challenge 值

3. `TestWebhookReceiver_InvalidSignature` - 签名验证失败
   - 发送带错误签名的请求
   - 验证返回 401（或 SDK 的错误响应）

4. `TestWebhookReceiver_MessageEvent` - 消息事件处理
   - 需要 mock 或跳过签名验证（可以用测试专用的 token）
   - 验证 MessageHandler 被调用

注意：飞书 SDK 的签名验证较难在单元测试中模拟，可以：
- 使用空字符串作为 token/key 跳过验证（如果 SDK 支持）
- 使用表驱动测试，标记需要真实环境的测试为 skip
- 重点测试 HTTP 层面的逻辑（method check, body limit）
  </action>
  <verify>
`go test -v ./internal/feishu/... -run TestWebhookReceiver` 测试通过（可能有部分 skip）
  </verify>
  <done>
WebhookReceiver 测试实现，覆盖 HTTP 层面逻辑和可测试的场景
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/feishu/...` 编译成功
- [ ] `go test -v ./internal/feishu/...` 全部通过
- [ ] WebhookReceiver 实现 FeishuReceiver 接口
- [ ] HTTP Server 配置正确（超时、body 限制）
- [ ] 事件处理流程：去重 -> 提交队列 -> 异步执行
</verification>

<success_criteria>
- WebhookReceiver 完整实现 FeishuReceiver 接口
- 使用 SDK dispatcher 处理 challenge、签名、解密
- 事件异步处理，HTTP 立即返回
- 优雅关闭等待任务完成
</success_criteria>

<output>
After completion, create `.planning/phases/02-webhook-server/02-02-SUMMARY.md`
</output>
