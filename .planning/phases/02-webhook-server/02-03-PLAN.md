---
phase: 02-webhook-server
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - internal/feishu/webhook_receiver.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "/health 端点返回服务健康状态"
    - "/metrics 端点返回 Prometheus 格式指标"
    - "指标包含请求计数、延迟直方图、队列深度"
  artifacts:
    - path: "internal/feishu/webhook_receiver.go"
      provides: "Health 和 Metrics 端点"
      contains: "/health"
    - path: "go.mod"
      provides: "Prometheus 依赖"
      contains: "prometheus/client_golang"
  key_links:
    - from: "internal/feishu/webhook_receiver.go"
      to: "prometheus"
      via: "promhttp.Handler"
      pattern: "promhttp\\.Handler"
---

<objective>
为 WebhookReceiver 添加 /health 和 /metrics 端点，支持 Kubernetes 探针和 Prometheus 监控。

Purpose: 运维需要健康检查和监控指标来了解服务状态，这是生产环境的基本要求。
Output: `/health` 返回健康状态，`/metrics` 返回 Prometheus 格式指标。
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webhook-server/02-RESEARCH.md (Pattern 5: Prometheus Metrics)
@.planning/phases/02-webhook-server/02-01-SUMMARY.md
@.planning/phases/02-webhook-server/02-02-SUMMARY.md
@internal/feishu/webhook_receiver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 添加 Prometheus 依赖和指标定义</name>
  <files>go.mod, internal/feishu/webhook_receiver.go</files>
  <action>
1. 添加 Prometheus 依赖：
```bash
go get github.com/prometheus/client_golang/prometheus
go get github.com/prometheus/client_golang/prometheus/promhttp
```

2. 在 `internal/feishu/webhook_receiver.go` 文件顶部（import 后）定义指标：
```go
var (
    webhookRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "feishu_webhook_requests_total",
            Help: "Total number of webhook requests received",
        },
        []string{"status"}, // "success", "error", "rejected"
    )

    webhookRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "feishu_webhook_request_duration_seconds",
            Help:    "Webhook request processing duration in seconds",
            Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0},
        },
        []string{"endpoint"},
    )

    workerQueueDepth = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "feishu_worker_queue_depth",
            Help: "Current number of jobs in worker queue",
        },
    )

    workerQueueCapacity = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "feishu_worker_queue_capacity",
            Help: "Maximum capacity of worker queue",
        },
    )
)

func init() {
    prometheus.MustRegister(webhookRequestsTotal)
    prometheus.MustRegister(webhookRequestDuration)
    prometheus.MustRegister(workerQueueDepth)
    prometheus.MustRegister(workerQueueCapacity)
}
```

3. 在 NewWebhookReceiver 中设置 capacity gauge：
```go
workerQueueCapacity.Set(float64(config.QueueSize))
```
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功，依赖已添加到 go.mod
  </verify>
  <done>
Prometheus 依赖添加，4 个指标定义完成并注册
  </done>
</task>

<task type="auto">
  <name>Task 2: 在请求处理中记录指标</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
修改 webhook HTTP handler，在请求处理中记录指标：

1. 在 HTTP handler 开始处记录开始时间：
```go
start := time.Now()
defer func() {
    webhookRequestDuration.WithLabelValues("/webhook/feishu").Observe(time.Since(start).Seconds())
}()
```

2. 在 Submit 成功时：
```go
webhookRequestsTotal.WithLabelValues("success").Inc()
```

3. 在 Submit 返回 ErrQueueFull 时：
```go
webhookRequestsTotal.WithLabelValues("rejected").Inc()
```

4. 在事件处理出错时：
```go
webhookRequestsTotal.WithLabelValues("error").Inc()
```

5. 定期更新队列深度（在去重缓存清理 goroutine 中或单独 goroutine）：
```go
go func() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            workerQueueDepth.Set(float64(wr.workerPool.QueueLen()))
        case <-ctx.Done():
            return
        }
    }
}()
```
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
指标在请求处理流程中正确记录
  </done>
</task>

<task type="auto">
  <name>Task 3: 添加 /health 和 /metrics 端点</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
在 Start 方法中注册额外的路由：

1. 添加 /health 端点：
```go
mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)

    health := struct {
        Status     string `json:"status"`
        QueueDepth int    `json:"queue_depth"`
        QueueCap   int    `json:"queue_capacity"`
    }{
        Status:     "healthy",
        QueueDepth: wr.workerPool.QueueLen(),
        QueueCap:   wr.config.QueueSize,
    }

    json.NewEncoder(w).Encode(health)
})
```

2. 添加 /metrics 端点：
```go
mux.Handle("/metrics", promhttp.Handler())
```

3. 更新启动日志，包含所有端点：
```go
log.Printf("[Webhook] Starting server on :%d", config.Port)
log.Printf("[Webhook]   Event endpoint: %s", config.Path)
log.Printf("[Webhook]   Health endpoint: /health")
log.Printf("[Webhook]   Metrics endpoint: /metrics")
log.Printf("[Webhook]   Workers: %d, Queue: %d", config.Workers, config.QueueSize)
```
  </action>
  <verify>
`go build ./internal/feishu/...` 编译成功
  </verify>
  <done>
/health 和 /metrics 端点实现完成
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/feishu/...` 编译成功
- [ ] `go mod tidy` 无错误
- [ ] Prometheus 依赖正确添加到 go.mod
- [ ] /health 端点返回 JSON 格式健康状态
- [ ] /metrics 端点返回 Prometheus 格式指标
- [ ] 指标包含：requests_total, request_duration, queue_depth, queue_capacity
- [ ] 队列深度指标验证：
  - 启动服务后 `curl localhost:8080/metrics | grep feishu_worker_queue_depth` 应返回当前队列深度
  - `curl localhost:8080/metrics | grep feishu_worker_queue_capacity` 应返回配置的队列容量
  - `/health` 返回的 `queue_depth` 和 `/metrics` 中的 `feishu_worker_queue_depth` 值应一致
</verification>

<success_criteria>
- /health 返回服务状态和队列信息
- /metrics 返回标准 Prometheus 格式指标
- 指标在请求处理流程中正确记录
- 队列深度指标实时反映 WorkerPool 状态
- 启动日志包含所有端点信息
</success_criteria>

<output>
After completion, create `.planning/phases/02-webhook-server/02-03-SUMMARY.md`
</output>
