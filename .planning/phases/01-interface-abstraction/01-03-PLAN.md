---
phase: 01-interface-abstraction
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - internal/bridge/bridge.go
  - cmd/bridge/main.go
autonomous: true

must_haves:
  truths:
    - "Bridge.feishuClient 类型为 FeishuSender 接口而非 *feishu.Client"
    - "删除 SetFeishuClient 后置注入模式"
    - "NewBridge 接受 FeishuSender 参数"
    - "WebSocket 模式功能完全不受影响"
  artifacts:
    - path: "internal/bridge/bridge.go"
      provides: "重构后的 Bridge，依赖接口而非具体类型"
      contains: "FeishuSender"
    - path: "cmd/bridge/main.go"
      provides: "更新后的启动逻辑"
  key_links:
    - from: "internal/bridge/bridge.go"
      to: "internal/feishu/sender.go"
      via: "FeishuSender interface"
      pattern: "feishu\\.FeishuSender"
    - from: "cmd/bridge/main.go"
      to: "internal/feishu/ws_receiver.go"
      via: "NewClient constructor"
      pattern: "feishu\\.NewClient"
---

<objective>
更新 Bridge 和 main.go 以使用 FeishuSender 接口，完成接口抽象重构。

Purpose: 让 Bridge 依赖接口而非具体实现，为后续添加 Webhook 模式铺路
Output: Bridge 使用 FeishuSender 接口，main.go 更新启动顺序
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md

# 依赖的前置计划
@.planning/phases/01-interface-abstraction/01-02-SUMMARY.md

# 需要修改的文件
@internal/bridge/bridge.go
@cmd/bridge/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 重构 Bridge 使用 FeishuSender 接口</name>
  <files>internal/bridge/bridge.go</files>
  <action>
修改 `internal/bridge/bridge.go`：

1. 修改 Bridge 结构体：
   ```go
   type Bridge struct {
       feishuClient   feishu.FeishuSender  // 改为接口类型
       clawdbotClient *clawdbot.Client
       thinkingMs     int
       seenMessages   *messageCache
   }
   ```

2. 修改 NewBridge 构造函数签名：
   ```go
   func NewBridge(feishuClient feishu.FeishuSender, clawdbotClient *clawdbot.Client, thinkingMs int) *Bridge {
       return &Bridge{
           feishuClient:   feishuClient,
           clawdbotClient: clawdbotClient,
           thinkingMs:     thinkingMs,
           seenMessages:   newMessageCache(10 * time.Minute),
       }
   }
   ```

3. 删除 SetFeishuClient 方法（不再需要后置注入）

4. 验证所有 feishuClient 调用仍然有效：
   - `b.feishuClient.SendMessage(chatID, text)` - OK，接口方法
   - `b.feishuClient.UpdateMessage(messageID, text)` - OK，接口方法
   - `b.feishuClient.DeleteMessage(messageID)` - OK，接口方法
  </action>
  <verify>
- 语法检查：`go build ./internal/bridge/...`
- 接口类型：`grep "feishu.FeishuSender" internal/bridge/bridge.go`
- 删除检查：`! grep "SetFeishuClient" internal/bridge/bridge.go`
  </verify>
  <done>
- Bridge.feishuClient 类型改为 feishu.FeishuSender
- NewBridge 接受 FeishuSender 参数
- 删除 SetFeishuClient 方法
  </done>
</task>

<task type="auto">
  <name>Task 2: 更新 main.go 启动逻辑</name>
  <files>cmd/bridge/main.go</files>
  <action>
修改 `cmd/bridge/main.go` 的 `cmdRun()` 函数：

1. 调整创建顺序（不再需要后置注入）：
   ```go
   func cmdRun() {
       // ... 配置加载 ...

       clawdbotClient := clawdbot.NewClient(
           cfg.Clawdbot.GatewayPort,
           cfg.Clawdbot.GatewayToken,
           cfg.Clawdbot.AgentID,
       )

       // 先创建 Bridge（feishuClient 暂时为 nil）
       // 因为 feishu.NewClient 需要 handler
       var bridgeInstance *bridge.Bridge

       feishuClient := feishu.NewClient(
           cfg.Feishu.AppID,
           cfg.Feishu.AppSecret,
           func(msg *feishu.Message) error {
               return bridgeInstance.HandleMessage(msg)
           },
       )

       // 创建 Bridge，传入 feishuClient
       bridgeInstance = bridge.NewBridge(feishuClient, clawdbotClient, cfg.Feishu.ThinkingThresholdMs)

       // ... 后续启动逻辑保持不变 ...
   }
   ```

2. 删除 `bridgeInstance.SetFeishuClient(feishuClient)` 调用

3. 确保 handler 闭包正确引用 bridgeInstance（通过先声明变量）

注意：这种模式解决了循环依赖问题：
- feishu.Client 需要 handler（Bridge.HandleMessage）
- Bridge 需要 feishuClient
- 解决方案：声明 bridgeInstance 变量，闭包捕获引用
  </action>
  <verify>
- 语法检查：`go build ./cmd/bridge/...`
- 删除检查：`! grep "SetFeishuClient" cmd/bridge/main.go`
- 全项目编译：`go build ./...`
  </verify>
  <done>
- main.go 不再调用 SetFeishuClient
- 使用闭包解决循环依赖
- 全项目编译成功
  </done>
</task>

<task type="auto">
  <name>Task 3: 端到端功能验证</name>
  <files></files>
  <action>
验证 WebSocket 模式功能不受影响：

1. 编译验证：
   ```bash
   go build -o /tmp/clawdbot-bridge ./cmd/bridge
   ```

2. 代码结构验证：
   ```bash
   # 确认接口文件存在
   ls internal/feishu/sender.go internal/feishu/receiver.go internal/feishu/ws_receiver.go

   # 确认旧文件不存在
   ! ls internal/feishu/client.go 2>/dev/null

   # 确认接口定义
   grep "type FeishuSender interface" internal/feishu/sender.go
   grep "type FeishuReceiver interface" internal/feishu/receiver.go

   # 确认 Bridge 使用接口
   grep "feishu.FeishuSender" internal/bridge/bridge.go
   ```

3. 运行简单测试（如果有）：
   ```bash
   go test ./... 2>/dev/null || echo "No tests yet"
   ```
  </action>
  <verify>
- 二进制构建成功：`test -f /tmp/clawdbot-bridge`
- 所有接口文件存在
- Bridge 依赖接口而非具体类型
  </verify>
  <done>
- 项目完整编译成功
- 代码结构符合 Phase 1 目标
- WebSocket 模式代码路径不变（只是类型抽象）
  </done>
</task>

</tasks>

<verification>
```bash
# 1. 全项目编译
go build ./...

# 2. 文件结构
ls -la internal/feishu/*.go

# 3. 接口使用验证
grep -r "FeishuSender\|FeishuReceiver" internal/

# 4. SetFeishuClient 已删除
! grep -r "SetFeishuClient" internal/ cmd/

# 5. 构建可执行文件
go build -o /tmp/clawdbot-bridge ./cmd/bridge && echo "Build OK"
```
</verification>

<success_criteria>
- [ ] Bridge.feishuClient 类型为 FeishuSender 接口
- [ ] 删除 SetFeishuClient 方法
- [ ] main.go 使用闭包解决循环依赖
- [ ] `go build ./...` 成功
- [ ] 可执行文件构建成功
- [ ] Phase 1 所有 Deliverables 完成
</success_criteria>

<output>
After completion, create `.planning/phases/01-interface-abstraction/01-03-SUMMARY.md`
</output>
