---
phase: 01-interface-abstraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/feishu/sender.go
  - internal/feishu/receiver.go
autonomous: true

must_haves:
  truths:
    - "FeishuSender 接口定义 SendMessage/UpdateMessage/DeleteMessage 三个方法"
    - "RESTSender 实现封装 lark.Client 的 REST 调用"
    - "FeishuReceiver 接口定义 Start(ctx) error 方法"
    - "MessageHandler 类型签名保持兼容"
  artifacts:
    - path: "internal/feishu/sender.go"
      provides: "FeishuSender 接口和 RESTSender 实现"
      exports: ["FeishuSender", "RESTSender", "NewRESTSender"]
    - path: "internal/feishu/receiver.go"
      provides: "FeishuReceiver 接口和 MessageHandler 类型"
      exports: ["FeishuReceiver", "MessageHandler"]
  key_links:
    - from: "internal/feishu/sender.go"
      to: "github.com/larksuite/oapi-sdk-go/v3"
      via: "lark.Client"
      pattern: "lark\\.NewClient"
---

<objective>
创建 FeishuSender 和 FeishuReceiver 接口定义，以及 RESTSender 实现。

Purpose: 为 WebSocket/Webhook 模式共享消息发送逻辑，将发送能力从 client.go 提取为独立模块
Output: sender.go 和 receiver.go 两个新文件
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md

# 现有代码参考
@internal/feishu/client.go (提取 SendMessage/UpdateMessage/DeleteMessage 逻辑)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 创建 sender.go - FeishuSender 接口和 RESTSender 实现</name>
  <files>internal/feishu/sender.go</files>
  <action>
创建 `internal/feishu/sender.go`，包含：

1. `FeishuSender` 接口定义：
   ```go
   type FeishuSender interface {
       SendMessage(chatID, text string) (messageID string, err error)
       UpdateMessage(messageID, text string) error
       DeleteMessage(messageID string) error
   }
   ```

2. `RESTSender` 结构体：
   ```go
   type RESTSender struct {
       client *lark.Client
   }
   ```

3. `NewRESTSender(appID, appSecret string) *RESTSender` 构造函数

4. 从 `client.go` 迁移以下方法到 RESTSender（保持逻辑不变）：
   - `SendMessage(chatID, text string) (string, error)`
   - `UpdateMessage(messageID, text string) error`
   - `DeleteMessage(messageID string) error`

5. 迁移辅助函数 `escapeJSON()` 到此文件

6. 添加接口合规性检查：
   ```go
   var _ FeishuSender = (*RESTSender)(nil)
   ```

注意：保持方法签名完全一致，只是从 Client 迁移到 RESTSender。
  </action>
  <verify>
- 文件存在：`ls internal/feishu/sender.go`
- 语法检查：`go build ./internal/feishu/...` 无报错
- 接口定义正确：`grep "type FeishuSender interface" internal/feishu/sender.go`
  </verify>
  <done>
- FeishuSender 接口定义了 3 个方法
- RESTSender 实现了 FeishuSender 接口
- NewRESTSender 构造函数可用
  </done>
</task>

<task type="auto">
  <name>Task 2: 创建 receiver.go - FeishuReceiver 接口和 MessageHandler 类型</name>
  <files>internal/feishu/receiver.go</files>
  <action>
创建 `internal/feishu/receiver.go`，包含：

1. `FeishuReceiver` 接口定义：
   ```go
   type FeishuReceiver interface {
       Start(ctx context.Context) error
   }
   ```

2. 将 `MessageHandler` 类型定义从 `client.go` 移动到此文件：
   ```go
   // MessageHandler is called when a message is received
   type MessageHandler func(msg *Message) error
   ```

3. 添加接口合规性检查的占位注释（实际检查在重构 client.go 后添加）：
   ```go
   // Interface compliance will be verified after Client refactoring:
   // var _ FeishuReceiver = (*Client)(nil)
   ```

注意：MessageHandler 签名必须与现有 client.go 中的定义完全一致。
  </action>
  <verify>
- 文件存在：`ls internal/feishu/receiver.go`
- 语法检查：`go build ./internal/feishu/...` 无报错
- 接口定义正确：`grep "type FeishuReceiver interface" internal/feishu/receiver.go`
  </verify>
  <done>
- FeishuReceiver 接口定义了 Start 方法
- MessageHandler 类型签名与原定义一致
- receiver.go 文件独立可编译
  </done>
</task>

</tasks>

<verification>
```bash
# 1. 文件存在
ls -la internal/feishu/sender.go internal/feishu/receiver.go

# 2. 语法正确
go build ./internal/feishu/...

# 3. 接口导出
go doc github.com/wy51ai/moltbotCNAPP/internal/feishu | grep -E "(FeishuSender|FeishuReceiver|RESTSender|MessageHandler)"
```
</verification>

<success_criteria>
- [ ] sender.go 创建，包含 FeishuSender 接口和 RESTSender 实现
- [ ] receiver.go 创建，包含 FeishuReceiver 接口和 MessageHandler 类型
- [ ] `go build ./internal/feishu/...` 成功
- [ ] 接口方法签名与 ROADMAP.md Phase 1 Deliverables 一致
</success_criteria>

<output>
After completion, create `.planning/phases/01-interface-abstraction/01-01-SUMMARY.md`
</output>
