---
phase: 03-config-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/config/config.go
  - cmd/bridge/main.go
autonomous: true

must_haves:
  truths:
    - "mode: webhook 配置启动 Webhook 模式"
    - "mode: websocket 或缺省启动 WebSocket 模式"
    - "Webhook 模式缺少 verification_token 或 encrypt_key 时拒绝启动"
    - "错误信息包含配置路径和修复提示"
    - "CLI 参数 mode=webhook 可覆盖配置文件"
  artifacts:
    - path: "internal/config/config.go"
      provides: "Mode 和 WebhookConfig 结构，验证逻辑"
      contains: "type WebhookConfig struct"
    - path: "cmd/bridge/main.go"
      provides: "模式切换逻辑"
      contains: "switch cfg.Mode"
  key_links:
    - from: "cmd/bridge/main.go"
      to: "internal/config/config.go"
      via: "cfg.Mode 和 cfg.Webhook"
      pattern: "cfg\\.Mode|cfg\\.Webhook"
    - from: "cmd/bridge/main.go"
      to: "internal/feishu/webhook_receiver.go"
      via: "feishu.NewWebhookReceiver"
      pattern: "feishu\\.NewWebhookReceiver"
    - from: "cmd/bridge/main.go"
      to: "internal/feishu/sender.go"
      via: "feishu.NewRESTSender (独立于 Client)"
      pattern: "feishu\\.NewRESTSender"
---

<objective>
扩展配置结构支持 Webhook 模式，在 main.go 实现 WebSocket/Webhook 模式切换。

Purpose: 让用户可以通过配置文件选择运行模式，Webhook 模式强制安全配置
Output: 可切换模式的 bridge 程序，清晰的配置错误提示
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-config-mode/03-CONTEXT.md

# 现有代码
@internal/config/config.go
@internal/feishu/webhook_receiver.go
@internal/feishu/sender.go
@cmd/bridge/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 扩展配置结构和验证</name>
  <files>internal/config/config.go</files>
  <action>
扩展 config 包支持 Mode 和 Webhook 配置：

1. 在 `Config` 结构添加字段：
   ```go
   type Config struct {
       Mode     string         // "websocket" | "webhook", 默认 "websocket"
       Feishu   FeishuConfig
       Webhook  WebhookConfig  // Webhook 模式配置
       Clawdbot ClawdbotConfig
   }
   ```

2. 添加 `WebhookConfig` 结构：
   ```go
   type WebhookConfig struct {
       Port              int    // 默认 9090 (CONTEXT.md 指定)
       Path              string // 默认 "/webhook/feishu"
       VerificationToken string // webhook 模式必填
       EncryptKey        string // webhook 模式必填
       Workers           int    // 默认 10
       QueueSize         int    // 默认 100
   }
   ```

3. 更新 `bridgeJSON` 添加解析字段：
   ```go
   type bridgeJSON struct {
       Mode    string `json:"mode,omitempty"`
       Feishu  struct { ... } `json:"feishu"`
       Webhook struct {
           Port              int    `json:"port,omitempty"`
           Path              string `json:"path,omitempty"`
           VerificationToken string `json:"verification_token"`
           EncryptKey        string `json:"encrypt_key"`
           Workers           int    `json:"workers,omitempty"`
           QueueSize         int    `json:"queue_size,omitempty"`
       } `json:"webhook,omitempty"`
       // 现有字段保留
   }
   ```

4. 在 `Load()` 函数中：
   - 解析 mode 字段，默认 "websocket"
   - 验证 mode 值有效（"websocket" 或 "webhook"）
   - 当 mode == "webhook" 时验证必填字段：
     - 缺少 verification_token: 返回错误
     - 缺少 encrypt_key: 返回错误
   - 填充默认值（port=9090, path="/webhook/feishu", workers=10, queue_size=100）

5. 错误信息格式（带条件语义）：
   ```
   ~/.clawdbot/bridge.json: webhook.verification_token is required when mode is "webhook"

   Add to your config:
     "webhook": {
       "verification_token": "your-token-from-feishu-console",
       "encrypt_key": "your-encrypt-key"
     }
   ```

注意：
- 无效 mode 值（非 websocket/webhook）应报错
- 保持现有 Feishu/Clawdbot 验证逻辑不变
  </action>
  <verify>
创建临时测试验证配置解析：
```bash
cd /Users/cookie/GolangProject/moltbotCNAPP
go build ./internal/config/...
```
  </verify>
  <done>
- Config 包含 Mode 和 WebhookConfig 字段
- mode: "webhook" 时验证 verification_token 和 encrypt_key
- 默认 mode 为 "websocket"
- 错误信息包含配置路径和修复提示
  </done>
</task>

<task type="auto">
  <name>Task 2: 实现模式切换逻辑</name>
  <files>cmd/bridge/main.go</files>
  <action>
更新 main.go 支持 WebSocket/Webhook 模式切换：

1. 更新 `bridgeConfigJSON` 添加 mode 和 webhook 字段：
   ```go
   type bridgeConfigJSON struct {
       Mode   string `json:"mode,omitempty"`
       Feishu struct { ... } `json:"feishu"`
       Webhook struct {
           Port              int    `json:"port,omitempty"`
           Path              string `json:"path,omitempty"`
           VerificationToken string `json:"verification_token,omitempty"`
           EncryptKey        string `json:"encrypt_key,omitempty"`
           Workers           int    `json:"workers,omitempty"`
           QueueSize         int    `json:"queue_size,omitempty"`
       } `json:"webhook,omitempty"`
       // 现有字段保留
   }
   ```

2. 更新 `applyConfigArgs` 支持 `mode=webhook` 参数：
   ```go
   if v, ok := kv["mode"]; ok {
       cfg.Mode = v
   }
   ```

3. 重构 `cmdRun()` 实现模式切换：
   ```go
   func cmdRun() {
       // 现有日志和配置加载...
       cfg, err := config.Load()

       clawdbotClient := clawdbot.NewClient(...)

       var bridgeInstance *bridge.Bridge

       switch cfg.Mode {
       case "webhook":
           // 打印启动信息
           log.Printf("[Main] Starting webhook mode on :%d%s (%d workers)",
               cfg.Webhook.Port, cfg.Webhook.Path, cfg.Webhook.Workers)

           // 创建独立的 RESTSender（不通过 Client）
           sender := feishu.NewRESTSender(cfg.Feishu.AppID, cfg.Feishu.AppSecret)

           // 创建 Bridge
           bridgeInstance = bridge.NewBridge(sender, clawdbotClient, cfg.Feishu.ThinkingThresholdMs)

           // 创建 WebhookReceiver
           receiver := feishu.NewWebhookReceiver(feishu.WebhookConfig{
               Port:              cfg.Webhook.Port,
               Path:              cfg.Webhook.Path,
               VerificationToken: cfg.Webhook.VerificationToken,
               EncryptKey:        cfg.Webhook.EncryptKey,
               Workers:           cfg.Webhook.Workers,
               QueueSize:         cfg.Webhook.QueueSize,
           }, func(msg *feishu.Message) error {
               return bridgeInstance.HandleMessage(msg)
           })

           // 启动 receiver
           go func() {
               if err := receiver.Start(ctx); err != nil {
                   errChan <- err
               }
           }()

       default: // "websocket" 或空
           log.Printf("[Main] Starting websocket mode...")
           // 现有 WebSocket 逻辑保持不变
           feishuClient := feishu.NewClient(...)
           bridgeInstance = bridge.NewBridge(feishuClient, ...)
           go func() {
               if err := feishuClient.Start(ctx); err != nil {
                   errChan <- err
               }
           }()
       }

       // 现有的信号处理和等待逻辑...
   }
   ```

4. 更新启动成功日志，包含模式信息：
   ```go
   log.Printf("[Main] ClawdBot Bridge started in %s mode", cfg.Mode)
   ```

注意：
- WebSocket 模式保持现有逻辑不变
- Webhook 模式使用独立的 NewRESTSender（不是 NewClient）
- 闭包模式解决循环依赖同样适用于 Webhook 模式
  </action>
  <verify>
```bash
cd /Users/cookie/GolangProject/moltbotCNAPP
go build -o /tmp/clawdbot-bridge ./cmd/bridge

# 测试 websocket 模式（默认）
/tmp/clawdbot-bridge run 2>&1 | head -5

# 测试 webhook 模式缺少配置应报错（需要手动验证错误信息）
```
  </verify>
  <done>
- cmdRun 根据 cfg.Mode 选择启动方式
- WebSocket 模式保持现有行为
- Webhook 模式使用 NewRESTSender + NewWebhookReceiver
- CLI 参数 mode=webhook 可保存到配置
- 启动日志显示模式和关键配置
  </done>
</task>

</tasks>

<verification>
1. 编译通过：`go build ./...`
2. WebSocket 模式（默认）正常启动
3. Webhook 模式缺少 verification_token 时报错并退出
4. 错误信息包含配置路径和修复建议
5. CLI 参数 `mode=webhook` 正确保存
</verification>

<success_criteria>
- [ ] `mode: "webhook"` 配置启动 Webhook 模式
- [ ] `mode: "websocket"` 或缺省启动 WebSocket 模式
- [ ] Webhook 模式缺少必填字段时报错信息清晰
- [ ] CLI 参数 `mode=webhook` 可覆盖配置
- [ ] 启动日志包含模式和配置摘要
- [ ] `go build ./...` 成功
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-mode/03-01-SUMMARY.md`
</output>
