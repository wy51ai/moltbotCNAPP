---
phase: 04-e2e-testing-docs
plan: 04
type: execute
wave: 2
depends_on:
  - "04-01"
  - "04-02"
files_modified:
  - test/integration/webhook_test.go
autonomous: true

must_haves:
  truths:
    - "SDK 签名错误返回 401 (契约保护)"
    - "集成测试用 build tag 隔离"
  artifacts:
    - path: "test/integration/webhook_test.go"
      provides: "SDK contract protection tests"
      contains: "//go:build integration"
  key_links:
    - from: "webhook_test.go"
      to: "WebhookReceiver.webhookHandler"
      via: "httptest request"
      pattern: "httptest.NewRequest"
---

<objective>
创建轻量集成测试，保护 SDK 契约，防止 SDK 升级后行为变化导致签名验证逻辑失效。

Purpose: Codex 评审收窄目标为 "只做 SDK 契约保护 (签名错误 -> 401)"。当前单元测试依赖 string contains 判断 SDK 错误消息，SDK 升级可能改变消息格式导致测试失效。集成测试提供额外保护层。

Output:
- test/integration/webhook_test.go 集成测试文件
- 使用 build tag 隔离，默认 go test 不运行
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-testing-docs/04-CONTEXT.md

# Codex 评审决策:
# - 04-04 目标收窄: 只做 SDK 契约保护 (签名错误 -> 401)
# - 用 build tag //go:build integration 隔离
# - 只做 1-2 条关键断言

@internal/feishu/webhook_receiver.go
@internal/feishu/webhook_receiver_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 创建集成测试目录和文件</name>
  <files>test/integration/webhook_test.go</files>
  <action>
创建 test/integration/ 目录和 webhook_test.go 文件:

```go
//go:build integration

package integration

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/wy51ai/moltbotCNAPP/internal/feishu"
)

// TestWebhook_SignatureVerification_Contract 测试 SDK 签名验证契约
// 目的: 防止 SDK 升级后签名验证行为变化
func TestWebhook_SignatureVerification_Contract(t *testing.T) {
	// 创建 WebhookReceiver
	wr := feishu.NewWebhookReceiver(feishu.WebhookConfig{
		VerificationToken: "contract_test_token",
		EncryptKey:        "contract_test_key_16chars", // 至少 16 字符
		Workers:           1,
		QueueSize:         10,
	}, func(msg *feishu.Message) error {
		return nil
	})

	// 需要初始化 dispatcher (通过 Start 或手动)
	// 由于 Start 会启动 HTTP server 阻塞，我们需要访问内部 handler
	// 方案: 使用 httptest 直接测试 handler

	// 注意: WebhookReceiver 的 webhookHandler 是私有方法
	// 需要通过启动完整 server 或反射访问
	// 最简方案: 启动 server 在后台，使用 httptest 或真实 HTTP 请求

	// 方案 A: 使用 httptest.Server 包装
	// 方案 B: 短暂启动真实 server

	// 采用方案 A (更可控):
	// 问题: webhookHandler 是私有的，无法直接访问
	// 解决: 我们测试公开的行为 - 通过完整 HTTP 请求验证

	t.Run("invalid signature returns 401", func(t *testing.T) {
		// 构造无签名的事件请求
		eventBody := map[string]interface{}{
			"schema": "2.0",
			"header": map[string]interface{}{
				"event_id":    "contract_test_event_1",
				"event_type":  "im.message.receive_v1",
				"create_time": "1234567890000",
				"token":       "contract_test_token",
				"app_id":      "cli_test",
				"tenant_key":  "tenant_test",
			},
			"event": map[string]interface{}{
				"message": map[string]interface{}{
					"message_id": "msg_contract_test",
				},
			},
		}
		body, _ := json.Marshal(eventBody)

		// 启动测试服务器
		// 由于 webhookHandler 是私有的，我们需要通过 Start 启动
		// 但 Start 会阻塞，所以使用 goroutine + 短暂等待

		// 更好的方案: 导出一个用于测试的 handler 或使用 httptest
		// 当前实现: 直接测试行为契约

		// 临时方案: 利用 createTestWebhookReceiver 类似逻辑
		// 但那是 _test.go 文件中的，集成测试看不到

		// 最终方案: 集成测试启动真实服务
		// 由于这是契约测试，我们验证行为而非实现

		t.Skip("需要启动真实服务器测试，暂时跳过")
		_ = body
	})
}
```

上述方案有问题 - webhookHandler 是私有方法，集成测试无法直接访问。

**修正方案**: 导出 HTTP handler 或创建测试 helper。

选择**方案 B**: 在 webhook_receiver.go 中添加一个导出的 Handler() 方法:

```go
// Handler returns the HTTP handler for testing purposes.
// This allows integration tests to use httptest without starting a full server.
func (wr *WebhookReceiver) Handler() http.Handler {
	mux := http.NewServeMux()
	mux.HandleFunc(wr.config.Path, wr.webhookHandler)
	mux.HandleFunc("/health", wr.healthHandler)
	return mux
}
```

然后集成测试可以:
```go
handler := wr.Handler()
server := httptest.NewServer(handler)
defer server.Close()
// 发送请求测试
```

但这需要修改 webhook_receiver.go，不符合 04-04 计划只创建测试文件的目标。

**最终方案**: 集成测试启动真实 goroutine 服务器，然后发送 HTTP 请求。

修正后的实现:

```go
//go:build integration

package integration

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"testing"
	"time"

	"github.com/wy51ai/moltbotCNAPP/internal/feishu"
)

// TestWebhook_SignatureVerification_Contract 测试 SDK 签名验证契约
func TestWebhook_SignatureVerification_Contract(t *testing.T) {
	port := 19090 // 使用非标准端口避免冲突

	wr := feishu.NewWebhookReceiver(feishu.WebhookConfig{
		Port:              port,
		Path:              "/webhook/feishu",
		VerificationToken: "integration_test_token",
		EncryptKey:        "integration_key_16ch",
		Workers:           1,
		QueueSize:         10,
	}, func(msg *feishu.Message) error {
		return nil
	})

	// 启动服务器 (后台)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	errCh := make(chan error, 1)
	go func() {
		errCh <- wr.Start(ctx)
	}()

	// 等待服务器启动
	time.Sleep(100 * time.Millisecond)

	baseURL := fmt.Sprintf("http://localhost:%d", port)

	t.Run("invalid signature returns 401", func(t *testing.T) {
		// 构造无签名的事件请求
		eventBody := map[string]interface{}{
			"schema": "2.0",
			"header": map[string]interface{}{
				"event_id":    "int_test_event_1",
				"event_type":  "im.message.receive_v1",
				"create_time": "1234567890000",
				"token":       "integration_test_token",
				"app_id":      "cli_test",
				"tenant_key":  "tenant_test",
			},
			"event": map[string]interface{}{
				"message": map[string]interface{}{
					"message_id": "msg_int_test",
				},
			},
		}
		body, _ := json.Marshal(eventBody)

		resp, err := http.Post(
			baseURL+"/webhook/feishu",
			"application/json",
			bytes.NewReader(body),
		)
		if err != nil {
			t.Fatalf("request failed: %v", err)
		}
		defer resp.Body.Close()

		// 契约断言: 无效签名必须返回 401
		if resp.StatusCode != http.StatusUnauthorized {
			t.Errorf("expected 401 Unauthorized for invalid signature, got %d", resp.StatusCode)
		}
	})

	// 停止服务器
	cancel()
	select {
	case err := <-errCh:
		if err != nil && err != http.ErrServerClosed {
			t.Logf("server error: %v", err)
		}
	case <-time.After(2 * time.Second):
		t.Log("server shutdown timeout")
	}
}
```
  </action>
  <verify>创建 test/integration/ 目录，文件存在且语法正确</verify>
  <done>集成测试文件创建，包含 build tag 和签名验证契约测试</done>
</task>

<task type="auto">
  <name>Task 2: 验证集成测试可运行</name>
  <files>test/integration/webhook_test.go</files>
  <action>
运行集成测试验证:

```bash
# 确保依赖正确
cd /Users/cookie/GolangProject/moltbotCNAPP
go mod tidy

# 运行集成测试 (需要 -tags=integration)
go test -tags=integration -v ./test/integration/...

# 验证默认 go test 不运行集成测试
go test -v ./test/... 2>&1 | grep -c "no test files" || echo "OK: integration tests skipped"
```

如果测试失败，检查:
1. 端口是否被占用 (改用其他端口)
2. 导入路径是否正确 (github.com/wy51ai/moltbotCNAPP/internal/feishu)
3. SDK 行为是否符合预期

预期结果:
- `go test -tags=integration ./test/integration/...` 通过
- 无效签名请求返回 401
  </action>
  <verify>`go test -tags=integration -v ./test/integration/...` 通过</verify>
  <done>集成测试验证通过，签名错误返回 401</done>
</task>

</tasks>

<verification>
- test/integration/webhook_test.go 文件存在
- 文件顶部有 `//go:build integration` tag
- `go test -tags=integration ./test/integration/...` 通过
- 普通 `go test ./...` 不运行集成测试
</verification>

<success_criteria>
- [ ] test/integration/ 目录已创建
- [ ] webhook_test.go 包含 //go:build integration tag
- [ ] 签名验证失败返回 401 的测试存在
- [ ] `go test -tags=integration ./test/integration/...` 通过
- [ ] `go test ./...` 不包含集成测试
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-testing-docs/04-04-SUMMARY.md`
</output>
