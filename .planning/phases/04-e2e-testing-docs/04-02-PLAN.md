---
phase: 04-e2e-testing-docs
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/feishu/webhook_receiver.go
  - internal/feishu/webhook_receiver_test.go
autonomous: true

must_haves:
  truths:
    - "Handler 执行耗时指标可在 /metrics 查看"
    - "签名验证失败时计数器递增"
    - "日志包含 event_id, message_id, duration_ms 字段"
  artifacts:
    - path: "internal/feishu/webhook_receiver.go"
      provides: "New Prometheus metrics and enhanced logging"
      contains: "feishu_message_processing_duration_seconds"
    - path: "internal/feishu/webhook_receiver_test.go"
      provides: "Observability regression tests"
      contains: "TestWebhookReceiver_Observability"
  key_links:
    - from: "handleMessageEvent"
      to: "feishu_message_processing_duration_seconds"
      via: "time.Since observation"
      pattern: "Observe.*Since"
    - from: "webhookHandler"
      to: "feishu_webhook_signature_failures_total"
      via: "Inc on signature failure"
      pattern: "signatureFailures.*Inc"
---

<objective>
增强 Webhook 接收器的可观测性，新增 handler 执行耗时指标和签名失败计数器，并增强日志字段。

Purpose: Codex 评审要求区分两种耗时口径 (HTTP 入站->返回 vs handler 执行)，并新增签名失败计数器。这些指标对生产环境排查问题至关重要。

Output:
- webhook_receiver.go 新增 2 个 Prometheus 指标
- webhook_receiver.go 日志增强为 key=value 格式
- webhook_receiver_test.go 新增可观测性回归测试
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-testing-docs/04-CONTEXT.md

# 现有指标 (webhook_receiver.go):
# - feishu_webhook_requests_total (Counter, labels: status)
# - feishu_webhook_request_duration_seconds (Histogram, labels: endpoint)
# - feishu_worker_queue_depth (Gauge)
# - feishu_worker_queue_capacity (Gauge)

# Codex 评审要求新增:
# - feishu_message_processing_duration_seconds (Histogram) - handler 执行耗时
# - feishu_webhook_signature_failures_total (Counter) - 签名失败计数

@internal/feishu/webhook_receiver.go
@internal/feishu/webhook_receiver_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 新增 Prometheus 指标</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
在 var() 块新增两个指标:

```go
// 新增指标
messageProcessingDuration = prometheus.NewHistogram(
    prometheus.HistogramOpts{
        Name:    "feishu_message_processing_duration_seconds",
        Help:    "Histogram of message handler execution duration",
        Buckets: prometheus.DefBuckets,
    },
)

signatureFailuresTotal = prometheus.NewCounter(
    prometheus.CounterOpts{
        Name: "feishu_webhook_signature_failures_total",
        Help: "Total number of signature verification failures",
    },
)
```

在 init() 函数注册:
```go
prometheus.MustRegister(messageProcessingDuration)
prometheus.MustRegister(signatureFailuresTotal)
```

在 handleMessageEvent 中记录 handler 执行耗时:
```go
// 在 Submit 之前记录开始时间
start := time.Now()

// 修改 Job.Handler 闭包，在 handler 完成后记录耗时
job := Job{
    EventID: eventID,
    Handler: func() error {
        defer func() {
            messageProcessingDuration.Observe(time.Since(start).Seconds())
        }()
        return wr.handler(msg)
    },
}
```

注意: 耗时从 Submit 前开始计，到 handler 执行完结束，包含队列等待时间。
如果只想测 handler 执行时间，把 start := time.Now() 放到 Handler 闭包内部。

根据 Codex 评审 "handler 执行耗时"，应该只测 handler 执行，所以:
```go
job := Job{
    EventID: eventID,
    Handler: func() error {
        start := time.Now()
        err := wr.handler(msg)
        messageProcessingDuration.Observe(time.Since(start).Seconds())
        return err
    },
}
```

在 webhookHandler 签名验证失败处增加计数:
```go
// 在 signature verification failed 分支
if contains(bodyStr, "signature verification failed") {
    signatureFailuresTotal.Inc()  // 新增
    log.Printf("[Webhook] Signature verification failed from %s", r.RemoteAddr)
    http.Error(w, "Unauthorized", http.StatusUnauthorized)
    return
}
```
  </action>
  <verify>`go build ./...` 编译通过，启动服务后 `curl localhost:9090/metrics | grep feishu_message` 可见新指标</verify>
  <done>新增 feishu_message_processing_duration_seconds 和 feishu_webhook_signature_failures_total 指标</done>
</task>

<task type="auto">
  <name>Task 2: 增强日志格式</name>
  <files>internal/feishu/webhook_receiver.go</files>
  <action>
修改 handleMessageEvent 中的日志为 key=value 格式:

现有日志:
```go
log.Printf("[Webhook] Duplicate event ignored: %s", eventID)
log.Printf("[Webhook] Queue full, event %s will be retried", eventID)
```

改为:
```go
log.Printf("[Webhook] event=duplicate event_id=%s", eventID)
log.Printf("[Webhook] event=queue_full event_id=%s", eventID)
```

在成功入队后新增日志 (含 message_id 和 event_id):
```go
// 在 Submit 成功后，获取 message_id
messageID := ""
if msg.MessageID != "" {
    messageID = msg.MessageID
}
log.Printf("[Webhook] event=enqueued event_id=%s message_id=%s", eventID, messageID)
```

在 handler 执行完成后记录耗时 (在 Job.Handler 闭包内):
```go
Handler: func() error {
    start := time.Now()
    err := wr.handler(msg)
    duration := time.Since(start)
    messageProcessingDuration.Observe(duration.Seconds())

    // 新增日志
    log.Printf("[Webhook] event=processed event_id=%s message_id=%s duration_ms=%d",
        eventID, messageID, duration.Milliseconds())

    return err
},
```

注意: messageID 需要在闭包外捕获 (msg 变量已捕获)。
  </action>
  <verify>启动服务发送测试请求，查看日志包含 event_id=... message_id=... duration_ms=...</verify>
  <done>日志格式统一为 key=value，包含 event_id, message_id, duration_ms</done>
</task>

<task type="auto">
  <name>Task 3: 可观测性回归测试</name>
  <files>internal/feishu/webhook_receiver_test.go</files>
  <action>
新增测试验证指标和日志:

```go
// TestWebhookReceiver_Observability_Metrics 测试新增指标
func TestWebhookReceiver_Observability_Metrics(t *testing.T) {
    // 注意: Prometheus 全局 registry 在 init() 注册
    // 测试需要获取指标值验证

    // 方案 A: 直接验证指标已注册 (简单)
    // 方案 B: 使用 promhttp.Handler 请求 /metrics 验证输出

    t.Run("metrics registered", func(t *testing.T) {
        // 验证指标变量不为 nil
        if messageProcessingDuration == nil {
            t.Error("messageProcessingDuration metric not initialized")
        }
        if signatureFailuresTotal == nil {
            t.Error("signatureFailuresTotal metric not initialized")
        }
    })

    t.Run("processing duration observed", func(t *testing.T) {
        // 创建 receiver，执行一次成功路径
        handlerCalled := make(chan struct{})
        wr := NewWebhookReceiver(WebhookConfig{
            VerificationToken: "test_token",
            EncryptKey:        "test_encrypt_key_1234",
        }, func(msg *Message) error {
            close(handlerCalled)
            return nil
        })
        wr.workerPool.Start()
        defer wr.workerPool.Shutdown(time.Second)

        // 构造事件并调用
        event := createTestMessageEvent("obs-test-event")
        err := wr.handleMessageEvent(event)
        if err != nil {
            t.Fatalf("handleMessageEvent failed: %v", err)
        }

        // 等待 handler 执行
        select {
        case <-handlerCalled:
            // OK
        case <-time.After(time.Second):
            t.Fatal("handler not called")
        }

        // 指标观测发生在 handler 内部，此时应该已记录
        // Prometheus Histogram 不容易直接读取，这里只验证无 panic
    })
}

// createTestMessageEvent 创建测试用 P2MessageReceiveV1 事件
func createTestMessageEvent(eventID string) *larkim.P2MessageReceiveV1 {
    return &larkim.P2MessageReceiveV1{
        EventV2Base: &larkevent.EventV2Base{
            Header: &larkevent.EventHeader{
                EventID: eventID,
            },
        },
        Event: &larkim.P2MessageReceiveV1Data{
            Message: &larkim.EventMessage{
                MessageId:   ptrStr("msg_" + eventID),
                ChatId:      ptrStr("chat_123"),
                ChatType:    ptrStr("group"),
                MessageType: ptrStr("text"),
                Content:     ptrStr(`{"text":"test"}`),
            },
        },
    }
}

// ptrStr 返回字符串指针 (辅助函数)
func ptrStr(s string) *string {
    return &s
}
```

如果 Task 1 中 createTestMessageEvent 和 ptrStr 已存在，直接复用。
  </action>
  <verify>`go test -v -run TestWebhookReceiver_Observability ./internal/feishu/...` 通过</verify>
  <done>可观测性测试: 验证指标注册、handler 执行时记录耗时无 panic</done>
</task>

</tasks>

<verification>
- `go build ./...` 编译通过
- `go test ./internal/feishu/...` 全部通过
- 手动验证: 启动服务，`curl localhost:9090/metrics` 可见:
  - feishu_message_processing_duration_seconds
  - feishu_webhook_signature_failures_total
</verification>

<success_criteria>
- [ ] feishu_message_processing_duration_seconds 指标已注册
- [ ] feishu_webhook_signature_failures_total 指标已注册
- [ ] 签名验证失败时 signatureFailuresTotal.Inc() 被调用
- [ ] handler 执行完成后记录 duration 到 Histogram
- [ ] 日志格式为 key=value，包含 event_id, message_id, duration_ms
- [ ] 可观测性回归测试通过
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-testing-docs/04-02-SUMMARY.md`
</output>
