---
phase: 04-e2e-testing-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/feishu/webhook_receiver_test.go
  - internal/config/config_test.go
autonomous: true

must_haves:
  truths:
    - "成功路径测试: P2MessageReceiveV1 事件入队并调用 handler"
    - "Bad request 内部层测试: header nil / event_id 空返回 ErrBadRequest"
    - "Bad request HTTP 层测试: webhookHandler 映射 ErrBadRequest 为 400"
    - "Config 验证测试: webhook 模式缺少必填字段报错"
  artifacts:
    - path: "internal/feishu/webhook_receiver_test.go"
      provides: "Webhook receiver unit tests"
      contains: "TestWebhookReceiver_SuccessPath"
    - path: "internal/config/config_test.go"
      provides: "Config validation tests"
      contains: "TestConfig"
  key_links:
    - from: "webhook_receiver_test.go"
      to: "handleMessageEvent"
      via: "直接构造 P2MessageReceiveV1 调用"
      pattern: "handleMessageEvent"
---

<objective>
补齐 Webhook 接收器单元测试覆盖，确保核心路径和边界场景有测试保护。

Purpose: 当前测试覆盖了 Challenge、签名验证失败、队列满、去重，但缺少成功路径和 bad request 场景测试。Codex 评审明确要求补齐这些测试。

Output:
- webhook_receiver_test.go 新增成功路径测试和 bad request 测试
- config_test.go 新增 webhook 模式验证测试
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-e2e-testing-docs/04-CONTEXT.md

# 已有测试覆盖分析
# webhook_receiver_test.go:
# - TestWebhookReceiver_NewWebhookReceiver (构造函数 panic + 默认值)
# - TestWebhookReceiver_MethodNotAllowed (405)
# - TestWebhookReceiver_BodyTooLarge (413)
# - TestWebhookReceiver_Challenge (url_verification)
# - TestWebhookReceiver_InvalidSignature (401)
# - TestWebhookReceiver_QueueFull (503)
# - TestWebhookReceiver_Deduplication (event_id 去重)
# - TestWebhookReceiver_CleanupDedupeCache
# - TestWebhookReceiver_ConvertEventToMessage

# 缺失测试 (Codex 评审要求):
# 1. 成功路径: 构造 P2MessageReceiveV1 -> 验证入队 + handler 调用
# 2. Bad request 内部层: handleMessageEvent 返回 ErrBadRequest
# 3. Bad request HTTP 层: webhookHandler 映射成 400

@internal/feishu/webhook_receiver.go
@internal/feishu/webhook_receiver_test.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: 成功路径单元测试</name>
  <files>internal/feishu/webhook_receiver_test.go</files>
  <action>
新增 TestWebhookReceiver_SuccessPath 测试:
1. 创建 WebhookReceiver，使用 mock handler 记录调用
2. 启动 workerPool
3. 直接构造 P2MessageReceiveV1 事件对象:
   - EventV2Base.Header.EventID = "test-success-event"
   - Event.Message 包含有效消息数据
4. 直接调用 handleMessageEvent(event)
5. 断言:
   - 返回值为 nil (无错误)
   - handler 被调用 (使用 channel 或 atomic counter)
   - 调用的 Message 包含正确字段

构造 P2MessageReceiveV1 示例:
```go
event := &larkim.P2MessageReceiveV1{
    EventV2Base: &larkevent.EventV2Base{
        Header: &larkevent.EventHeader{
            EventID: "test-success-event-123",
        },
    },
    Event: &larkim.P2MessageReceiveV1Data{
        Message: &larkim.EventMessage{
            MessageId:   ptrStr("msg_id_123"),
            ChatId:      ptrStr("chat_id_123"),
            ChatType:    ptrStr("group"),
            MessageType: ptrStr("text"),
            Content:     ptrStr(`{"text":"hello"}`),
        },
    },
}
```

需要辅助函数 ptrStr(s string) *string
  </action>
  <verify>`go test -v -run TestWebhookReceiver_SuccessPath ./internal/feishu/...` 通过</verify>
  <done>成功路径测试验证: 有效事件入队、handler 被调用、Message 字段正确</done>
</task>

<task type="auto">
  <name>Task 2: Bad Request 测试 (内部层 + HTTP 层)</name>
  <files>internal/feishu/webhook_receiver_test.go</files>
  <action>
新增两个测试函数:

1. TestWebhookReceiver_BadRequest_Internal:
   - 测试 handleMessageEvent 返回 ErrBadRequest 的场景
   - Case A: header 为 nil
     ```go
     event := &larkim.P2MessageReceiveV1{EventV2Base: nil}
     err := wr.handleMessageEvent(event)
     assert err == ErrBadRequest
     ```
   - Case B: EventV2Base 存在但 Header 为 nil
     ```go
     event := &larkim.P2MessageReceiveV1{
         EventV2Base: &larkevent.EventV2Base{Header: nil},
     }
     ```
   - Case C: event_id 为空字符串
     ```go
     event := &larkim.P2MessageReceiveV1{
         EventV2Base: &larkevent.EventV2Base{
             Header: &larkevent.EventHeader{EventID: ""},
         },
     }
     ```

2. TestWebhookReceiver_BadRequest_HTTP:
   - 验证 webhookHandler 将 ErrBadRequest 映射成 HTTP 400
   - 方法: 检查 webhookHandler 中的 error mapping 逻辑
   - 由于 SDK 介入，直接测试 contains 检查:
     ```go
     // 验证 error mapping 代码路径存在
     if contains(bodyStr, ErrBadRequest.Error()) {
         // 应返回 400
     }
     ```
   - 构造模拟响应验证逻辑正确性 (table-driven test)
  </action>
  <verify>`go test -v -run "TestWebhookReceiver_BadRequest" ./internal/feishu/...` 通过</verify>
  <done>Bad request 测试覆盖: 内部层返回 ErrBadRequest，HTTP 层映射成 400</done>
</task>

<task type="auto">
  <name>Task 3: Config 验证单元测试</name>
  <files>internal/config/config_test.go</files>
  <action>
创建新文件 internal/config/config_test.go:

```go
package config

import (
    "os"
    "path/filepath"
    "testing"
)

// TestConfig_WebhookModeValidation 测试 webhook 模式必填字段验证
func TestConfig_WebhookModeValidation(t *testing.T) {
    // 使用临时目录模拟 ~/.clawdbot
    tmpDir := t.TempDir()

    // 创建 clawdbot.json (gateway config)
    gwConfig := `{"gateway":{"port":18789,"auth":{"token":"test"}}}`
    os.WriteFile(filepath.Join(tmpDir, "clawdbot.json"), []byte(gwConfig), 0644)

    tests := []struct {
        name        string
        bridgeJSON  string
        wantErr     bool
        errContains string
    }{
        {
            name: "websocket mode without webhook config",
            bridgeJSON: `{"mode":"websocket","feishu":{"app_id":"cli_xxx","app_secret":"yyy"}}`,
            wantErr: false,
        },
        {
            name: "webhook mode missing verification_token",
            bridgeJSON: `{"mode":"webhook","feishu":{"app_id":"cli_xxx","app_secret":"yyy"},"webhook":{"encrypt_key":"key123"}}`,
            wantErr: true,
            errContains: "verification_token",
        },
        {
            name: "webhook mode missing encrypt_key",
            bridgeJSON: `{"mode":"webhook","feishu":{"app_id":"cli_xxx","app_secret":"yyy"},"webhook":{"verification_token":"token123"}}`,
            wantErr: true,
            errContains: "encrypt_key",
        },
        {
            name: "webhook mode with all required fields",
            bridgeJSON: `{"mode":"webhook","feishu":{"app_id":"cli_xxx","app_secret":"yyy"},"webhook":{"verification_token":"token123","encrypt_key":"key123"}}`,
            wantErr: false,
        },
        {
            name: "invalid mode value",
            bridgeJSON: `{"mode":"invalid","feishu":{"app_id":"cli_xxx","app_secret":"yyy"}}`,
            wantErr: true,
            errContains: "invalid mode",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 写入 bridge.json
            os.WriteFile(filepath.Join(tmpDir, "bridge.json"), []byte(tt.bridgeJSON), 0644)

            // 需要 mock Dir() 函数或使用环境变量
            // 由于 Dir() 使用 os.UserHomeDir，需要修改测试策略
            // 方案: 创建 loadFromDir(dir string) 内部函数用于测试
        })
    }
}
```

注意: config.Load() 直接使用 os.UserHomeDir()，无法直接测试。
选项 A (推荐): 添加内部函数 loadFromDir(dir string) (*Config, error) 供测试使用
选项 B: 使用 t.Setenv("HOME", tmpDir) (仅 Unix)

选用选项 B (简单且 Go 1.17+ 支持)，但需要在代码中加 //go:build !windows
  </action>
  <verify>`go test -v ./internal/config/...` 通过</verify>
  <done>Config 验证测试: 验证 webhook 模式必填字段、无效 mode 值报错</done>
</task>

</tasks>

<verification>
- `go test ./internal/feishu/...` 全部通过
- `go test ./internal/config/...` 全部通过
- 新增测试覆盖: 成功路径、bad request (内部+HTTP)、config 验证
</verification>

<success_criteria>
- [ ] TestWebhookReceiver_SuccessPath 测试通过
- [ ] TestWebhookReceiver_BadRequest_Internal 测试通过
- [ ] TestWebhookReceiver_BadRequest_HTTP 测试通过或有等效覆盖
- [ ] TestConfig_WebhookModeValidation 测试通过
- [ ] `go test ./internal/feishu/... ./internal/config/...` 全部通过
</success_criteria>

<output>
After completion, create `.planning/phases/04-e2e-testing-docs/04-01-SUMMARY.md`
</output>
